# TODO

* Eliminate duplicate declaration of JniEnv

* Functions to create jvalues from any allocator

* Write JniClass, JniMethod, JniStaticMethod, JniObject, JniThrowable;
	Or extensions on corresponding types.

* Hide CallMethod[V] methods, only A methods can be called from dart.

* JString cache if at all makes sense

* Function callbacks from Dart_Handle if at all makes sense.
	- java.lang.reflect.Proxy

* test & benchmark application
	* stdlibTests // should run on both flutter and dart
	* jarFileTests // use some popular jar
	* androidPlatformTests
	* androidPlatformExampleTable // also test, but semi-manual

* Bundling with dart standalone application

* Hide typedefs in API signatures
	- Is it analyzer bug? DartDoc shows expected behavior.

* Hide methods with `__va_list_tag` type

## Bugs
* double typedef generated by ffigen (JniEnv, JniEnv1), don't know why. It's harmless but confusing to the user.

* Typedef's should be exposed properly;
	-> Eg: JObject should be seen as JObject, not Pointer<Void>
	-> Currently it's a typedef, which makes it exposed as bare type to consumer library ?

* Inspect NDK / gradle warning on Android release build

## Next
* Utility functions
class JniUtil
	- [X] getJNIEnv, getJavaVM, getApplicationContext, getClassLoader
	- [] findClass, findMethod, jvalueArray
	- [] invoke, invoke, invokeStatic, invoke -> JValue
	* invokeStaticOn(cls, mId, args);
	* deleteJniRefs(localReferences: []);
	* exceptionDescribe()

	* StringCache(params)
	* UTF16 string type with length

class Jni
	- final jni = Platform.isAndroid ? Jni.getInstance() : Jni.spawn(library_path, log_level, jvm_opts);
	- Jni.getInstance()

src/
typedefs.dart
extensions.dart
convert.dart
jni_util.dart

jni.dart

